#!/usr/bin/env python2
import os, multiprocessing, subprocess
class gup:
    """ updates git stuff, hopefully in parallel"""
    def __init__(self):
        self.home = os.path.expanduser('~')
        home = self.home
        self.repos = [
                        home + '/.password-store',
                        home + '/.mutt',
                        home,
                        home + '/.oh-my-zsh/',
                        home + '/.oh-my-zsh/custom/plugins/zsh-aliases/',
                        home + '/.oh-my-zsh/custom/plugins/drush/',
                     ]
        # arrays used in subprocess.call and such
        self.pull = ['git', 'pull']
        self.push = ['git', 'push']
        self.ppull = ['pass', 'git', 'pull']
        self.ppush = ['pass', 'git', 'push']
        self.zupdate = ['git', 'pull', '--rebase', '--stat', 'origin', 'master']
        self.zcommit = ['git', 'commit', '-m', 'blah blah blah']
        self.mcommit =['git', 'commit', '--all', '-m', "mail $now"]
        self.mlink = ['ln', '-fv', home +'/.mutt/.muttrc', home + '/.muttrc']
        self.local_status = ['git', 'rev-parse', '@']
        self.remote_status = ['git', 'rev-parse', '@{u}']
        self.merge_base = ['git', 'merge-base', '@', '@{u}']

    def num_changes(self):
        """ Gets the number of changes to a git repo"""
        git = subprocess.Popen(['git', 'status'], stdout=subprocess.PIPE)
        grep = subprocess.Popen(['grep', 'modified'], stdin=git.stdout, stdout=subprocess.PIPE)
        wc = subprocess.Popen(['wc', '-l'], stdin=grep.stdout, stdout=subprocess.PIPE)
        git.stdout.close()
        grep.stdout.close()
        output, err = wc.communicate()
        output = output.strip()
        if not err:
            return output

    def list_changes(self):
        """ Lists changes to a git repo """
        git = subprocess.Popen(['git', 'status'], stdout=subprocess.PIPE)
        grep = subprocess.Popen(['grep', 'modified'], stdin=git.stdout, stdout=subprocess.PIPE)
        git.stdout.close()
        output, err = grep.communicate()
        output = output.strip()
        if not err:
            return output

    def check_status(self):
        """ Supposed to see whose ahead and whose behind"""
        c_local = subprocess.check_output(self.local_status)
        c_remote = subprocess.check_output(self.remote_status)
        c_merge = subprocess.check_output(self.merge_base)
        if c_local == c_remote:
            # ok
            return 0
        elif c_local == c_merge:
            # pull
            return -1
        elif c_remote == c_merge:
            #push
            return 1
        else:
            return 2

    def pull_push(self, pull, push):
        """ Actually does the work """
        stat = self.check_status()
        if stat != 0:
            if stat == -1:
                print '\n' + os.getcwd() + '\n' + str(subprocess.call(pull))
            elif stat == 1:
                print '\n' + os.getcwd() + '\n' + str(subprocess.call(push))
            else:
                print '\n' + os.getcwd() + '\n' + str(subprocess.call(pull))
                print '\n' + os.getcwd() + '\n' + str(subprocess.call(push))
        else:
            print self.show_message()
        return

    def show_message(self):
        changes = self.num_changes()
        if int(changes) == 1:
            message =  '\n' + os.getcwd() + ' is up to date with ' + self.num_changes() + ' change unstaged. \n\t' + self.list_changes()
        else:
            if int(changes) > 0:
                message =  '\n' +  os.getcwd() + ' is up to date with ' + self.num_changes() + ' unstaged changes.\n\t' + self.list_changes()
            else:
                message =  '\n' + os.getcwd() + ' is up to date with ' + self.num_changes() + ' unstaged changes.'
        return message

    def do_it(self, repo):
        """ wrapper function,
        checks current working directory and does the right thing based on that """
        pwd = os.getcwd()
        os.chdir(repo)
        if pwd != self.home + '/.oh-my-zsh':
            self.pull_push(self.pull, self.push)
        if pwd == self.home + '/.oh-my-zsh':
            self.pull_push(self.zupdate, self.push)
        if pwd == self.home + '/.password-store':
            self.pull_push(self.ppull, self.ppush)
        return

    def run(self):
        """ simplify calling stuff"""
        repos = self.repos
        jobs = []
        for repo in repos:
            p = multiprocessing.Process(target=gup().do_it, args=(repo,))
            p.start()

if __name__ == '__main__':
    g = gup()
    g.run()
    subprocess.call(g.mlink)
